# 生产者消费者

:::tip 备注
从[这](https://github.com/yangchong211/YCBlogs)转载！！！
:::

## 生产者消费者模型发生场景
- 生产者消费者模型发生场景
    - 多线程-并发协作(生产者消费者模型)。多线程同步的经典问题！


## 什么是生产者消费者模型
- 什么是生产者消费者模型，举例式说明
    - 准确说应该是“生产者-消费者-仓储”模型
    - 1、生产者仅仅在仓储未满时候生产，仓满则停止生产。
    - 2、消费者仅仅在仓储有产品时候才能消费，仓空则等待。
    - 3、当消费者发现仓储没产品可消费时候会通知生产者生产。
    - 4、生产者在生产出可消费产品时候，应该通知等待的消费者去消费。
- 专业术语说明什么是生产者消费者模型
    - 生产者消费者模型通过一个缓存队列，既解决了生产者和消费者之间强耦合的问题，又平衡了生产者和消费者的处理能力。
    - 具体规则：生产者只在缓存区未满时进行生产，缓存区满时生产者进程被阻塞；消费者只在缓存区非空时进行消费，缓存区为空时消费者进程被阻塞；当消费者发现缓存区为空时会通知生产者生产；当生产者发现缓存区满时会通知消费者消费。
    - 实现关键：```synchronized```保证对象只能被一个线程占用；```wait()```让当前线程进入等待状态，并释放它所持有的锁；```notify()```&```notifyAll()```唤醒一个（所有）正处于等待状态的线程。


## 一生产与一消费案例
- 下面代码案例是一个生产者，一个消费者的模式。
    - 假设场景：一个```String```对象，其中生产者为其设置值，消费者拿走其中的值，不断的循环往复，实现生产者/消费者的情形。
    - 实现方式：**```wait()```/```notify()```实现**
- 生产者
    ``` java
    public class Product {
        private String lock;
    
        public Product(String lock) {
            super();
            this.lock = lock;
        }
        public void setValue(){
            try {
                synchronized (lock) {
                    if(!StringObject.value.equals("")){
                        //有值，不生产
                        lock.wait();
                    }
                    String  value = System.currentTimeMillis()+""+System.nanoTime();
                    System.out.println("set的值是："+value);
                    StringObject.value = value;
                    lock.notify();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    ```
- 消费者
    ``` java
    public class Consumer {
        private String lock;
    
        public Consumer(String lock) {
            super();
            this.lock = lock;
        }
        public void getValue(){
            try {
                synchronized (lock) {
                    if(StringObject.value.equals("")){
                        //没值，不进行消费
                        lock.wait();
                    }
                    System.out.println("get的值是："+StringObject.value);
                    StringObject.value = "";
                    lock.notify();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    ```
- 生产者线程
    ``` java
    public class ThreadProduct extends Thread{
        private Product product;
    
        public ThreadProduct(Product product) {
            super();
            this.product = product;
        }
        @Override
        public void run() {
            //死循环，不断的生产
            while(true){
                product.setValue();
            }
        }
    }
    ```
- 消费者线程
    ``` java
    public class ThreadConsumer extends Thread{
        private Consumer consumer;
    
        public ThreadConsumer(Consumer consumer) {
            super();
            this.consumer = consumer;
        }
        @Override
        public void run() {
            //死循环，不断的消费
            while(true){
                consumer.getValue();
            }
        }
    }
    ```
- 开启生产者/消费者模式
    ``` java
    public class Test {
        public static void main(String[] args) throws InterruptedException {
            String lock = new String("");
            Product product = new Product(lock);
            Consumer consumer = new Consumer(lock);
            ThreadProduct pThread = new ThreadProduct(product);
            ThreadConsumer cThread = new ThreadConsumer(consumer);
            pThread.start();
            cThread.start();
        }
    }
    ```
- 输出结果：
    > set的值是：148827033184127168687409691  
    > get的值是：148827033184127168687409691  
    > set的值是：148827033184127168687449887  
    > get的值是：148827033184127168687449887  
    > set的值是：148827033184127168687475117  
    > get的值是：148827033184127168687475117



### 04.多生产与多消费案例
- **特殊情况：** 按照上述一生产与一消费的情况，通过创建多个生产者和消费者线程，实现多生产与多消费的情况，将会出现“假死”。
- **具体原因：** 多个生产者和消费者线程。当全部运行后，生产者线程生产数据后，可能唤醒的同类即生产者线程。此时可能会出现如下情况：所有生产者线程进入等待状态，然后消费者线程消费完数据后，再次唤醒的还是消费者线程，直至所有消费者线程都进入等待状态，此时将进入“假死”。
- **解决方法：** 将```notify()```或```signal()```方法改为```notifyAll()```或```signalAll()```方法，这样就不怕因为唤醒同类而进入“假死”状态了。
- **Condition方式实现**
- 生产者
    ``` java
    public class Product {
        private ReentrantLock lock;
        private Condition condition;
    
        public Product(ReentrantLock lock, Condition condition) {
            super();
            this.lock = lock;
            this.condition = condition;
        }
    
        public void setValue() {
            try {
                lock.lock();
                while (!StringObject.value.equals("")) {
                    // 有值，不生产
                    condition.await();
                }
                String value = System.currentTimeMillis() + "" + System.nanoTime();
                System.out.println("set的值是：" + value);
                StringObject.value = value;
                condition.signalAll();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                lock.unlock();
            }
        }
    }
    ```
- 消费者
    ``` java
    public class Consumer {
        private ReentrantLock lock;
        private Condition condition;
    
        public Consumer(ReentrantLock lock,Condition condition) {
            super();
            this.lock = lock;
            this.condition = condition;
        }
        public void getValue(){
            try {
                    lock.lock();
                    while(StringObject.value.equals("")){
                        //没值，不进行消费
                        condition.await();
                    }
                    System.out.println("get的值是："+StringObject.value);
                    StringObject.value = "";
                    condition.signalAll();
    
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                lock.unlock();
            }
        }
    }
    ```
    - 生产者线程和消费者线程与一生产一消费的模式相同。
- 开启多生产/多消费模式
  ``` java
    public static void main(String[] args) throws InterruptedException {
        ReentrantLock lock = new ReentrantLock();
        Condition newCondition = lock.newCondition();
        Product product = new Product(lock,newCondition);
        Consumer consumer = new Consumer(lock,newCondition);
        for(int i=0;i<3;i++){
            ThreadProduct pThread = new ThreadProduct(product);
            ThreadConsumer cThread = new ThreadConsumer(consumer);
            pThread.start();
            cThread.start();
        }
    }
    ```
- 输出结果:
    > set的值是：148827212374628960540784817  
    > get的值是：148827212374628960540784817  
    > set的值是：148827212374628960540810047  
    > get的值是：148827212374628960540810047
- 可见交替地进行```get```/```set```实现多生产/多消费模式。

**注意：相比一生产一消费的模式，改动了两处。①signal\(\)--&gt;signalAll\(\)避免进入“假死”状态。②if\(\)判断--&gt;while\(\)循环，重新判断条件，避免逻辑混乱。**


## 会遇到哪些关键问题
- 如何保证同一资源被多个线程并发访问时的完整性。常用的同步方法是采用信号或加锁机制，保证资源在任意时刻至多被一个线程访问。
- 如何保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区空时消耗数据？
- 实际开发时案例
    - 这种并发情况下，一般服务端程序用的比较多，Android端的应用程序较少有什么并发情况。虽然事实如此，但是构建生产者-消费者模型，是线程间协作的思想，工作线程的协助是为了让UI线程更好的完成工作，提高用户体验。比如，图片选择查看器案例！




## 如何解决关键问题
- 如何保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区空时消耗数据，思考一下？
- 解决思路可以简单概括为：
    - 生产者持续生产，直到缓冲区满，满时阻塞；缓冲区不满后，继续生产；
    - 消费者持续消费，直到缓冲区空，空时阻塞；缓冲区不空后，继续消费；
    - 生产者和消费者都可以有多个；
- 能够让消费者和生产者在各自满足条件需要阻塞时能够起到正确的作用
    - ```wait()```/```notify()```方式；
    - ```await()```/```signal()```方式；
    - ```BlockingQueue```阻塞队列方式；
    - ```PipedInputStream```/```PipedOutputStream```方式；
- 一般可以使用第一种和第三种方式实现逻辑。

















